<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Post Sockets, An Abstract Programming Interface for the Transport Layer</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 525px);
    width: 300px;
    z-index: 1;
  }
  #rfc\.toc {
    top: 15px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-right: 350px;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 25px auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
/*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Abstractions and Terminology">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Message Carrier">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Message">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Association">
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 Remote">
<link href="#rfc.section.2.5" rel="Chapter" title="2.5 Local">
<link href="#rfc.section.2.6" rel="Chapter" title="2.6 Policy Context">
<link href="#rfc.section.2.7" rel="Chapter" title="2.7 Transient">
<link href="#rfc.section.2.8" rel="Chapter" title="2.8 Path">
<link href="#rfc.section.3" rel="Chapter" title="3 Abstract Programming Interface">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Example Connection Patterns">
<link href="#rfc.section.3.1.1" rel="Chapter" title="3.1.1 Client-Server">
<link href="#rfc.section.3.1.2" rel="Chapter" title="3.1.2 Client-Server with Happy Eyeballs and 0-RTT establishment">
<link href="#rfc.section.3.1.3" rel="Chapter" title="3.1.3 Peer to Peer with Network Address Translation">
<link href="#rfc.section.3.1.4" rel="Chapter" title="3.1.4 Multicast Receiver">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Association Bootstrapping">
<link href="#rfc.section.4" rel="Chapter" title="4 Implementation Considerations">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Protocol Stack Instance (PSI)">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Message Framing, Parsing, and Serialization">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Message Size Limitations">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Back-pressure">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Associations, Transients, Racing, and Rendezvous">
<link href="#rfc.section.5" rel="Chapter" title="5 Acknowledgments">
<link href="#rfc.references" rel="Chapter" title="6 References">
<link href="#rfc.references.1" rel="Chapter" title="6.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="6.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Open Issues">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.8.0 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Trammell, B., Perkins, C., Pauly, T., Kuehlewind, M., and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-trammell-taps-post-sockets-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-9-07" />
  <meta name="dct.abstract" content="This document describes Post Sockets, an asynchronous abstract programming interface for the atomic transmission of messages in an inherently multipath environment. Post replaces connections with long-lived associations between endpoints, with the possibility to cache cryptographic state in order to reduce amortized connection latency. We present this abstract interface as an illustration of what is possible with present developments in transport protocols when freed from the strictures of the current sockets API." />
  <meta name="description" content="This document describes Post Sockets, an asynchronous abstract programming interface for the atomic transmission of messages in an inherently multipath environment. Post replaces connections with long-lived associations between endpoints, with the possibility to cache cryptographic state in order to reduce amortized connection latency. We present this abstract interface as an illustration of what is possible with present developments in transport protocols when freed from the strictures of the current sockets API." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">TAPS Working Group</td>
<td class="right">B. Trammell</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">ETH Zurich</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">C. Perkins</td>
</tr>
<tr>
<td class="left">Expires: March 11, 2018</td>
<td class="right">University of Glasgow</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">T. Pauly</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Apple Inc.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">M. Kuehlewind</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">ETH Zurich</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Wood</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Apple Inc.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">September 07, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Post Sockets, An Abstract Programming Interface for the Transport Layer<br />
  <span class="filename">draft-trammell-taps-post-sockets-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes Post Sockets, an asynchronous abstract programming interface for the atomic transmission of messages in an inherently multipath environment. Post replaces connections with long-lived associations between endpoints, with the possibility to cache cryptographic state in order to reduce amortized connection latency. We present this abstract interface as an illustration of what is possible with present developments in transport protocols when freed from the strictures of the current sockets API.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on March 11, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Abstractions and Terminology</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Message Carrier</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Message</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Association</a>
</li>
<li>2.4.   <a href="#rfc.section.2.4">Remote</a>
</li>
<li>2.5.   <a href="#rfc.section.2.5">Local</a>
</li>
<li>2.6.   <a href="#rfc.section.2.6">Policy Context</a>
</li>
<li>2.7.   <a href="#rfc.section.2.7">Transient</a>
</li>
<li>2.8.   <a href="#rfc.section.2.8">Path</a>
</li>
</ul><li>3.   <a href="#rfc.section.3">Abstract Programming Interface</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Example Connection Patterns</a>
</li>
<ul><li>3.1.1.   <a href="#rfc.section.3.1.1">Client-Server</a>
</li>
<li>3.1.2.   <a href="#rfc.section.3.1.2">Client-Server with Happy Eyeballs and 0-RTT establishment</a>
</li>
<li>3.1.3.   <a href="#rfc.section.3.1.3">Peer to Peer with Network Address Translation</a>
</li>
<li>3.1.4.   <a href="#rfc.section.3.1.4">Multicast Receiver</a>
</li>
</ul><li>3.2.   <a href="#rfc.section.3.2">Association Bootstrapping</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Implementation Considerations</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Protocol Stack Instance (PSI)</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Message Framing, Parsing, and Serialization</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Message Size Limitations</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Back-pressure</a>
</li>
<li>4.5.   <a href="#rfc.section.4.5">Associations, Transients, Racing, and Rendezvous</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Acknowledgments</a>
</li>
<li>6.   <a href="#rfc.references">References</a>
</li>
<ul><li>6.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>6.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Open Issues</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">The BSD Unix Sockets API&#8217;s SOCK_STREAM abstraction, by bringing network sockets into the UNIX programming model, allowing anyone who knew how to write programs that dealt with sequential-access files to also write network applications, was a revolution in simplicity. It would not be an overstatement to say that this simple API is the reason the Internet won the protocol wars of the 1980s. SOCK_STREAM is tied to the Transmission Control Protocol (TCP), specified in 1981 <a href="#RFC0793" class="xref">[RFC0793]</a>. TCP has scaled remarkably well over the past three and a half decades, but its total ubiquity has hidden an uncomfortable fact: the network is not really a file, and stream abstractions are too simplistic for many modern application programming models.</p>
<p id="rfc.section.1.p.2">In the meantime, the nature of Internet access, and the variety of Internet transport protocols, is evolving. The challenges that new protocols and access paradigms present to the sockets API and to programming models based on them inspire the design elements of a new approach.</p>
<p id="rfc.section.1.p.3">Many end-user devices are connected to the Internet via multiple interfaces, which suggests it is time to promote the paths by which two endpoints are connected to each other to a first-order object. While implicit multipath communication is available for these multihomed nodes in the present Internet architecture with the Multipath TCP extension (MPTCP) <a href="#RFC6824" class="xref">[RFC6824]</a>, MPTCP was specifically designed to hide multipath communication from the application for purposes of compatibility. Since many multihomed nodes are connected to the Internet through access paths with widely different properties with respect to bandwidth, latency and cost, adding explicit path control to MPTCP&#8217;s API would be useful in many situations.</p>
<p id="rfc.section.1.p.4">Another trend straining the traditional layering of the transport stack associated with the SOCK_STREAM interface is the widespread interest in ubiquitous deployment of encryption to guarantee confidentiality, authenticity, and integrity, in the face of pervasive surveillance <a href="#RFC7258" class="xref">[RFC7258]</a>. Layering the most widely deployed encryption technology, Transport Layer Security (TLS), strictly atop TCP (i.e., via a TLS library such as OpenSSL that uses the sockets API) requires the encryption-layer handshake to happen after the transport-layer handshake, which increases connection setup latency on the order of one or two round-trip times, an unacceptable delay for many applications. Integrating cryptographic state setup and maintenance into the path abstraction naturally complements efforts in new protocols (e.g. QUIC <a href="#I-D.ietf-quic-transport" class="xref">[I-D.ietf-quic-transport]</a>) to mitigate this strict layering.</p>
<p id="rfc.section.1.p.5">To meet these challenges, we present the Post-Sockets Application Programming Interface (API), described in detail in this work. Post is designed to be language, transport protocol, and architecture independent, allowing applications to be written to a common abstract interface, easily ported among different platforms, and used even in environments where transport protocol selection may be done dynamically, as proposed in the IETF&#8217;s Transport Services working group.</p>
<p id="rfc.section.1.p.6">Post replaces the traditional SOCK_STREAM abstraction with a Message abstraction, which can be seen as a generalization of the Stream Control Transmission Protocol&#8217;s <a href="#RFC4960" class="xref">[RFC4960]</a> SOCK_SEQPACKET service. Messages are sent and received on Carriers, which logically group Messages for transmission and reception. For backward compatibility, bidirectional byte stream protocols are represented as a pair of Messages, one in each direction, that can only be marked complete when the sending peer has finished transmitting data.</p>
<p id="rfc.section.1.p.7">Post replaces the notions of a socket address and connected socket with an Association with a remote endpoint via set of Paths.  Implementation and wire format for transport protocol(s) implementing the Post API are explicitly out of scope for this work; these abstractions need not map directly to implementation-level concepts, and indeed with various amounts of shimming and glue could be implemented with varying success atop any sufficiently flexible transport protocol.</p>
<p id="rfc.section.1.p.8">The key features of Post as compared with the existing sockets API are:</p>
<p></p>

<ul>
<li>Explicit Message orientation, with framing and atomicity guarantees for Message transmission.</li>
<li>Asynchronous reception, allowing all receiver-side interactions to be event-driven.</li>
<li>Explicit support for multistreaming and multipath transport protocols and network architectures.</li>
<li>Long-lived Associations, whose lifetimes may not be bound to underlying transport connections. This allows associations to cache state and cryptographic key material to enable fast resumption of communication, and for the implementation of the API to explicitly take care of connection establishment mechanics such as connection racing <a href="#RFC6555" class="xref">[RFC6555]</a> and peer-to-peer rendezvous <a href="#RFC5245" class="xref">[RFC5245]</a>.</li>
<li>Transport protocol stack independence, allowing applications to be written in terms of the semantics best for the application&#8217;s own design, separate from the protocol(s) used on the wire to achieve them. This enables applications written to a single API to make use of transport protocols in terms of the features they provide, as in <a href="#I-D.ietf-taps-transports" class="xref">[I-D.ietf-taps-transports]</a>.</li>
</ul>
<p id="rfc.section.1.p.10">This work is the synthesis of many years of Internet transport protocol research and development. It is inspired by concepts from the Stream Control Transmission Protocol (SCTP) <a href="#RFC4960" class="xref">[RFC4960]</a>, TCP Minion <a href="#I-D.iyengar-minion-protocol" class="xref">[I-D.iyengar-minion-protocol]</a>, and MinimaLT <a href="#MinimaLT" class="xref">[MinimaLT]</a>, among other transport protocol modernization efforts. We present Post as an illustration of what is possible with present developments in transport protocols when freed from the strictures of the current sockets API. While much of the work for building parts of the protocols needed to implement Post are already ongoing in other IETF working groups (e.g. MPTCP, QUIC, TLS), we argue that an abstract programming interface unifying access all these efforts is necessary to fully exploit their potential.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#abstractions-and-terminology" id="abstractions-and-terminology">Abstractions and Terminology</a>
</h1>
<div id="rfc.figure.1"></div>
<div id="fig-abstractions"></div>
<pre>
           +===============+
           |    Message    |
           +===============+
                |    ^         |               |
          send()|    |ready()  |initiate()     |listen()
                V    |         V               V
           +=====================+           +============+
           |                     |  accept() |            |
           |      Carrier        |&lt;----------|  Listener  |
           |                     |           |            |
           +=====================+           +============+
            |1        |        n|                  |          +=========+
            |         |         |1                 |      +---|  Local  |
            |   +=========+   +=======================+   |   +=========+
            |   | Policy  |n  |                       |---+
            |   | Context |---|      Association      |       +=========+
            |   |         |  1|                       |-------|  Remote |
            |   +=========+   +=======================+       +=========+
            |         |                1| durable end-to-end
            +-------+ |                 | state via many paths,
                    | |                 | policies, and prefs  
                   n| |                n|
               +===========+       +==========+
     ephemeral |           |       |          |
   transport &amp; | Transient |-------|   Path   | properties of
  crypto state |           |n     1|          | address pair
               +===========+       +==========+

</pre>
<p class="figure">Figure 1: Abstractions and relationships in Post Sockets</p>
<p id="rfc.section.2.p.1">Post is based on a small set of abstractions, centered around a Message Carrier as the entry point for an application to the networking API.  The relationships among them are shown in Figure <a href="#fig-abstractions" class="xref">Figure 1</a> and detailed in this section.</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#carrier" id="carrier">Message Carrier</a>
</h1>
<p id="rfc.section.2.1.p.1">A Message Carrier (or simply Carrier) is a transport protocol stack-independent interface for sending and receiving messages between an application and a remote endpoint; it is roughly analogous to a socket in the present sockets API.</p>
<p id="rfc.section.2.1.p.2">Sending a Message over a Carrier is driven by the application, while receipt is driven by the arrival of the last packet that allows the Message to be assembled, decrypted, and passed to the application. Receipt is therefore asynchronous; given the different models for asynchronous I/O and concurrency supported by different platforms, it may be implemented in any number of ways.  The abstract API provides only for a way for the application to register how it wants to handle incoming messages.</p>
<p id="rfc.section.2.1.p.3">All the Messages sent to a Message Carrier will be received on the corresponding Message Carrier at the remote endpoint, though not necessarily reliably or in order, depending on Message properties and the underlying transport protocol stack.</p>
<p id="rfc.section.2.1.p.4">A Message Carrier that is backed by current transport protocol stack state (such as a TCP connection; see <a href="#transient" class="xref">Section 2.7</a>) is said to be &#8220;active&#8221;: messages can be sent and received over it. A Message Carrier can also be &#8220;dormant&#8221;: there is long-term state associated with it (via the underlying Association; see <a href="#association" class="xref">Section 2.3</a>), and it may be able to reactivated, but messages cannot be sent and received immediately.</p>
<p id="rfc.section.2.1.p.5">If supported by the underlying transport protocol stack, a Message Carrier may be forked: creating a new Message Carrier associated with a new Message Carrier at the same remote endpoint. The semantics of the usage of multiple Message Carriers based on the same Association are application-specific. When a Message Carrier is forked, its corresponding Message Carrier at the remote endpoint receives a fork request, which it must accept in order to fully establish the new carrier. Multiple message carriers between endpoints are implemented differently by different transport protocol stacks, either using multiple separate transport-layer connections, or using multiple streams of multistreaming transport protocols.</p>
<p id="rfc.section.2.1.p.6">To exchange messages with a given remote endpoint, an application may initiate a Message Carrier given its remote (see <a href="#remote" class="xref">Section 2.4</a> and local (see <a href="#local" class="xref">Section 2.5</a>) identities; this is an equivalent to an active open. There are four special cases of Message Carriers, as well, supporting different initiation and interaction patterns, defined in the subsections below.</p>
<p></p>

<ul>
<li>Listener: A Listener is a special case of Message Carrier which only responds to requests to create a new Carrier from a remote endpoint, analogous to a server or listening socket in the present sockets API. Instead of being bound to a specific remote endpoint, it is bound only to a local identity; however, its interface for accepting fork requests is identical to that for fully fledged Message Carriers.</li>
<li>Source: A Source is a special case of Message Carrier over which messages can only be sent, intended for unidirectional applications such as multicast transmitters.  Sources cannot be forked, and need not accept forks.</li>
<li>Sink: A Sink is a special case of Message Carrier over which messages can only be received, intended for unidirectional applications such as multicast receivers. Sinks cannot be forked, and need not accept forks.</li>
<li>Responder: A Responder is a special case of Message Carrier which may receive messages from many remote sources, for cases in which an application will only ever send Messages in reply back to the source from which a Message was received.  This is a common implementation pattern for servers in client-server applications. A Responder&#8217;s receiver gets a Message, as well as a Source to send replies to. Responders cannot be forked, and need not accept forks.</li>
</ul>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#message" id="message">Message</a>
</h1>
<p id="rfc.section.2.2.p.1">A Message is the unit of communication between applications. Messages can represent relatively small structures, such as requests in a request/response protocol such as HTTP; relatively large structures, such as files of arbitrary size in a filesystem; and structures of indeterminate length, such as a stream of bytes in a protocol like TCP.</p>
<p id="rfc.section.2.2.p.2">In the general case, there is no mapping between a Message and packets sent by the underlying protocol stack on the wire: the transport protocol may freely segment messages and/or combine messages into packets. However, a message may be marked as immediate, which will cause it to be sent in a single packet when possible.</p>
<p id="rfc.section.2.2.p.3">Content may be sent and received either as Complete or Partial Messages.  Dealing with Complete Messages should be preferred for simplicity whenever possible based on the underlying protocol. It is always possible to send Complete Messages, but only protocols that have a fixed maximum message length may allow clients to receive Messages using an API that guarantees Complete Messages.  Sending and receiving Partial Messages (that is, a Message whose content spans multiple calls or callbacks) is always possible.</p>
<p id="rfc.section.2.2.p.4">To send a Message, either Complete or Partial, the Message content is passed into the Carrier, and client provides a set of callbacks to know when the Message was delivered or acknowledged. The client of the API may use the callbacks to pace the sending of Messages.</p>
<p id="rfc.section.2.2.p.5">To receive a Message, the client of the API schedules a completion to be called when a Complete or Partial Message is available. If the client is willing to accept Partial Messages, it can specify the minimum incomplete Message length it is willing to receive at once, and the maximum number of bytes it is willing to receive at once. If the client wants Complete Messages, there are no values to tune. The scheduling of the receive completion indicates to the Carrier that there is a desire to receive bytes, effectively creating a &#8220;pull model&#8221; in which backpressure may be applied if the client is not receiving Messages or Partial Messages quickly enough to match the peer&#8217;s sending rate. The Carrier may have some minimal buffer of incoming Messages ready for the client to read to reduce latency.</p>
<p id="rfc.section.2.2.p.6">When receiving a Complete Message, the entire content of the Message must be delivered at once, and the Message is not delivered at all if the full Message is not received.  This implies that both the sending and receiving endpoint, whether in the application or the carrier, must guarantee storage for the full size of a Message.</p>
<p id="rfc.section.2.2.p.7">Partial Messages may be sent or received in several stages, with a handle representing the total Message being associated with each portion of the content. Each call to send or receive also indicates whether or not the Message is now complete. This approach is necessary whenever the size of the Message does not have a known bound, or the size is too large to process and hold in memory. Protocols that only present a concept of byte streams represent their data as single Messages with unknown bounds.  In the case of TCP, the client will receive a single Message in pieces using the Partial Message API, and that Message will only be marked as complete when the peer has sent a FIN.</p>
<p id="rfc.section.2.2.p.8">Messages are sent over and received from Message Carriers (see <a href="#carrier" class="xref">Section 2.1</a>).</p>
<p id="rfc.section.2.2.p.9">On sending, Messages have properties that allow the application to specify its requirements with respect to reliability, ordering, priority, idempotence, and immediacy; these are described in detail below. Messages may also have arbitrary properties which provide additional information to the underlying transport protocol stack on how they should be handled, in a protocol-specific way. These stacks may also deliver or set properties on received messages, but in the general case a received messages contains only a sequence of ordered bytes.  Message properties include:</p>
<p></p>

<ul>
<li>Lifetime and Partial Reliability: A Message may have a &#8220;lifetime&#8221; &#8211; a wall clock duration before which the Message must be available to the application layer at the remote end. If a lifetime cannot be met, the Message is discarded as soon as possible. Messages without lifetimes are sent reliably if supported by the transport protocol stack. Lifetimes are also used to prioritize Message delivery.  <br><br> There is no guarantee that a Message will not be delivered after the end of its lifetime; for example, a Message delivered over a strictly reliable transport will be delivered regardless of its lifetime. Depending on the transport protocol stack used to transmit the message, these lifetimes may also be signalled to path elements by the underlying transport, so that path elements that realize a lifetime cannot be met can discard frames containing the Messages instead of forwarding them.</li>
<li>Priority: Messages have a &#8220;niceness&#8221; &#8211; a priority among other messages sent over the same Message Carrier in an unbounded hierarchy most naturally represented as a non-negative integer. By default, Messages are in niceness class 0, or highest priority. Niceness class 1 Messages will yield to niceness class 0 Messages sent over the same Carrier, class 2 to class 1, and so on. Niceness may be translated to a priority signal for exposure to path elements (e.g. DSCP code point) to allow prioritization along the path as well as at the sender and receiver. This inversion of normal schemes for expressing priority has a convenient property: priority increases as both niceness and lifetime decrease. A Message may have both a niceness and a lifetime &#8211; Messages with higher niceness classes will yield to lower classes if resource constraints mean only one can meet the lifetime.</li>
<li>Dependence: A Message may have &#8220;antecedents&#8221; &#8211; other Messages on which it depends, which must be delivered before it (the &#8220;successor&#8221;) is delivered.  The sending transport uses deadlines, niceness, and antecedents, along with information about the properties of the Paths available, to determine when to send which Message down which Path.</li>
<li>Idempotence: A sending application may mark a Message as &#8220;idempotent&#8221; to signal to the underlying transport protocol stack that its application semantics make it safe to send in situations that may cause it to be received more than once (i.e., for 0-RTT session resumption as in TCP Fast Open, TLS 1.3, and QUIC).</li>
<li>Immediacy: A sending application may mark a Message as &#8220;immediate&#8221; to signal to the underlying transport protocol stack that its application semantics require it to be placed in a single packet, on its own, instead of waiting to be combined with other messages or parts thereof (i.e., for media transports and interactive sessions with small messages).</li>
</ul>
<p id="rfc.section.2.2.p.11">Senders may also be asynchronously notified of three events on Messages they have sent: that the Message has been transmitted, that the Message has been acknowledged by the receiver, or that the Message has expired before transmission/acknowledgement. Not all transport protocol stacks will support all of these events.</p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> <a href="#association" id="association">Association</a>
</h1>
<p id="rfc.section.2.3.p.1">An Association contains the long-term state necessary to support communications between a Local (see <a href="#local" class="xref">Section 2.5</a>) and a Remote (see <a href="#remote" class="xref">Section 2.4</a>) endpoint, such as trust model information, including pinned public keys or anchor certificates, cryptographic session resumption parameters, or rendezvous information. It uses information from the Policy Context (see <a href="#PolicyContext" class="xref">Section 2.6</a>) to constrain the selection of transport protocols and local interfaces to create Transients (see <a href="#transient" class="xref">Section 2.7</a>) to carry Messages; and information about the paths through the network available available between them (see <a href="#path" class="xref">Section 2.8</a>).</p>
<p id="rfc.section.2.3.p.2">All Message Carriers are bound to an Association. New Message Carriers will reuse an Association if they can be carried from the same Local to the same Remote over the same Paths; this re-use of an Association may implies the creation of a new Transient.</p>
<p id="rfc.section.2.3.p.3">Associations may exist and be created without a Message Carrier. This may be done if peer cryptographic state such as a pre-shared key is established out-of-band.  Thus, Associations may be created without the need to send application data to a peer, that is, without a Carrier. Associations are mutable. Association state may expire over time, after which it is removed from the Association, and Transients may export cryptographic state to store in an Association as needed.  Moreover, this state may be exported directly into the Association or modified before insertion. This may be needed to diversify ephemeral Transient keying material from the longer-term Association keying material.</p>
<p id="rfc.section.2.3.p.4">A primary use of Association state is to allow new Associations and their derived Carriers to be quickly created without performing in-band cryptographic handshakes.  See <a href="#I-D.kuehlewind-taps-crypto-sep" class="xref">[I-D.kuehlewind-taps-crypto-sep]</a> for more details about this separation.</p>
<h1 id="rfc.section.2.4">
<a href="#rfc.section.2.4">2.4.</a> <a href="#remote" id="remote">Remote</a>
</h1>
<p id="rfc.section.2.4.p.1">A Remote represents information required to establish and maintain a connection with the far end of an Association: name(s), address(es), and transport protocol parameters that can be used to establish a Transient; transport protocols to use; trust model information, inherited from the relevant Association, used to identify the remote on connection establishment; and so on. Each Association is associated with a single Remote, either explicitly by the application (when created by the initiation of a Message Carrier) or a Listener (when created by forking a Message Carrier on passive open).</p>
<p id="rfc.section.2.4.p.2">A Remote may be resolved, which results in zero or more Remotes with more specific information. For example, an application may want to establish a connection to a website identified by a URL https://www.example.com. This URL would be wrapped in a Remote and passed to a call to initiate a Message Carrier. The first pass resolution might parse the URL, decomposing it into a name, a transport port, and a transport protocol to try connecting with. A second pass resolution would then look up network-layer addresses associated with that name through DNS, and store any certificates available from DANE.  Once a Remote has been resolved to the point that a transport protocol stack can use it to create a Transient, it is considered fully resolved.</p>
<h1 id="rfc.section.2.5">
<a href="#rfc.section.2.5">2.5.</a> <a href="#local" id="local">Local</a>
</h1>
<p id="rfc.section.2.5.p.1">A Local represents all the information about the local endpoint necessary to establish an Association or a Listener: interface, port, and transport protocol stack information, and, per <a href="#I-D.pauly-taps-transport-security" class="xref">[I-D.pauly-taps-transport-security]</a>, cryptographic identities (certificates and associated private keys) bound to this endpoint.</p>
<h1 id="rfc.section.2.6">
<a href="#rfc.section.2.6">2.6.</a> <a href="#PolicyContext" id="PolicyContext">Policy Context</a>
</h1>
<p id="rfc.section.2.6.p.1">The Policy Context describes preferences for, and restrictions on, how to configure Transients to support communication between a Local and a Remote over one or more Paths between endpoints.  For instance, an application may require, or prefer to use, certain features (see <a href="#I-D.ietf-taps-transports" class="xref">[I-D.ietf-taps-transports]</a>) of the transport protocol stacks used by the Transients underlying the Carrier.  Alternatively, it might also prefer Paths over one interface to those over another (e.g., WiFi access over LTE when roaming on a foreign LTE network, due to cost).</p>
<p id="rfc.section.2.6.p.2">These policies are expressed in the Policy Context(s) that are bound to the Association.  Multiple policy contexts can be active at once.  For example, a system Policy Context can express the administrative preferences around network interface and protocol selection, while an application Policy Context expresses preferences for use of different transport services.  Expression of policy contexts and the resolution of conflicts among Policy Contexts is currently implementation-specific (the Policy API in the NEAT architecture <a href="#NEAT" class="xref">[NEAT]</a> provides an example of how this can be done).</p>
<h1 id="rfc.section.2.7">
<a href="#rfc.section.2.7">2.7.</a> <a href="#transient" id="transient">Transient</a>
</h1>
<p id="rfc.section.2.7.p.1">A Transient represents a binding between a Message Carrier and the instance of the transport protocol stack that implements it. As an Association contains long-term state for communications between two endpoints, a Transient contains ephemeral state for a single transport protocol over a single Path at a given point in time.</p>
<p id="rfc.section.2.7.p.2">A Message Carrier may be served by multiple Transients at once, e.g. when implementing multipath communication such that the separate paths are exposed to the API by the underlying transport protocol stack. Each Transient serves only one Message Carrier, although multiple Transients may share the same underlying protocol stack; e.g. when multiplexing Carriers over streams in a multistreaming protocol.</p>
<p id="rfc.section.2.7.p.3">Transients are generally not exposed by the API to the application, though they may be accessible for debugging and logging purposes.</p>
<h1 id="rfc.section.2.8">
<a href="#rfc.section.2.8">2.8.</a> <a href="#path" id="path">Path</a>
</h1>
<p id="rfc.section.2.8.p.1">A Path represents information about a single path through the network used by an Association, in terms of source and destination network and transport layer addresses within an addressing context, and the provisioning domain <a href="#RFC7556" class="xref">[RFC7556]</a> of the local interface. This information may be learned through a resolution, discovery, or rendezvous process (e.g. DNS, ICE), by measurements taken by the transport protocol stack, or by some other path information discovery mechanism.  It is used by the transport protocol stack to maintain and/or (re-)establish communications for the Association.</p>
<p id="rfc.section.2.8.p.2">The set of available properties is a function of the transport protocol stacks in use by an association. However, the following core properties are generally useful for applications and transport layer protocols to choose among paths for specific Messages:</p>
<p></p>

<ul>
<li>Maximum Transmission Unit (MTU): the maximum size of an Message&#8217;s payload (subtracting transport, network, and link layer overhead) which will likely fit into a single frame. Derived from signals sent by path elements, where available, and/or path MTU discovery processes run by the transport layer.</li>
<li>Latency Expectation: expected one-way delay along the Path. Generally provided by inline measurements performed by the transport layer, as opposed to signaled by path elements.</li>
<li>Loss Probability Expectation: expected probability of a loss of any given single frame along the Path. Generally provided by inline measurements performed by the transport layer, as opposed to signaled by path elements.</li>
<li>Available Data Rate Expectation: expected maximum data rate along the Path. May be derived from passive measurements by the transport layer, or from signals from path elements.</li>
<li>Reserved Data Rate: Committed, reserved data rate for the given Association along the Path. Requires a bandwidth reservation service in the underlying transport protocol stack.</li>
<li>Path Element Membership: Identifiers for some or all nodes along the path, depending on the capabilities of the underlying network layer protocol to provide this.</li>
</ul>
<p id="rfc.section.2.8.p.4">Path properties are generally read-only. MTU is a property of the underlying link-layer technology on each link in the path; latency, loss, and rate expectations are dynamic properties of the network configuration and network traffic conditions; path element membership is a function of network topology.  In an explicitly multipath architecture, application and transport layer requirements can be met by having multiple paths with different properties to select from. Transport protocol stacks can also provide signaling to devices along the path, but this signaling is derived from information provided to the Message abstraction.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#abstract-programming-interface" id="abstract-programming-interface">Abstract Programming Interface</a>
</h1>
<p id="rfc.section.3.p.1">We now turn to the design of an abstract programming interface to provide a simple interface to Post&#8217;s abstractions, constrained by the following design principles:</p>
<p></p>

<ul>
<li>Flexibility is paramount. So is simplicity. Applications must be given as many controls and as much information as they may need, but they must be able to ignore controls and information irrelevant to their operation. This implies that the &#8220;default&#8221; interface must be no more complicated than BSD sockets, and must do something reasonable.</li>
<li>Reception is an inherently asynchronous activity. While the API is designed to be as platform-independent as possible, one key insight it is based on is that an Message receiver&#8217;s behavior in a packet-switched network is inherently asynchronous, driven by the receipt of packets, and that this asynchronicity must be reflected in the API. The actual implementation of receive and event handling will need to be aligned to the method a given platform provides for asynchronous I/O.</li>
<li>A new API cannot be bound to a single transport protocol and expect wide deployment. As the API is transport-independent and may support runtime transport selection, it must impose the minimum possible set of constraints on its underlying transports, though some API features may require underlying transport features to work optimally. It must be possible to implement Post over vanilla TCP in the present Internet architecture.</li>
</ul>
<p id="rfc.section.3.p.3">The API we design from these principles is centered around a Carrier, which can be created actively via initiate() or passively via a listen(); the latter creates a Listener from which new Carriers can be accept()ed.  Messages may be created explicitly and passed to this Carrier, or implicitly through a simplified interface which uses default message properties (reliable transport without priority or deadline, which guarantees ordered delivery over a single Carrier when the underlying transport protocol stack supports it).</p>
<p id="rfc.section.3.p.4">For each connection between a Local and a Remote a new Carrier is created and destroyed when the connection is closed. However, a new Carrier may use an existing Association if present for the requested Local-Remote pair and permitted by the PolicyContext that can be provided at Carrier initiation. Further the system-wide PolicyContext can contain more information that determine when to create or destroy Associations other than at Carrier initiation. E.g. an Association can be created at system start, based on the configured PolicyContext or also by a manual action of an single application, for Local-Remote pairs that are known to be likely used soon, and to pre-establish, e.g., cryptographic context as well as potentially collect current information about path capabilities. Every time an actual connection with a specific PSI is established between the Local and Remote, the Association learns new Path information and stores them. This information can be used when a new transient is created, e.g. to decide which PSI to use (to provide the highest probably for a successful connection attempt) or which PSIs to probe for (first). A Transient is created when an application actually sends a Message over a Carrier. As further explained below this step can actually create multiple transients for probing or assign a new transient to an already active PSI, e.g. if multi-streaming is provided and supported for these kind of use on both sides.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#example-connection-patterns" id="example-connection-patterns">Example Connection Patterns</a>
</h1>
<p id="rfc.section.3.1.p.1">Here, we illustrate the usage of the API for common connection patterns. Note that error handling is ignored in these illustrations for ease of reading.</p>
<h1 id="rfc.section.3.1.1">
<a href="#rfc.section.3.1.1">3.1.1.</a> <a href="#client-server" id="client-server">Client-Server</a>
</h1>
<p id="rfc.section.3.1.1.p.1">Here&#8217;s an example client-server application. The server echoes messages. The client sends a message and prints what it receives.</p>
<p id="rfc.section.3.1.1.p.2">The client in <a href="#fig-client" class="xref">Figure 2</a> connects, sends a message, and sets up a receiver to print messages received in response. The carrier is inactive after the Initiate() call; the Send() call blocks until the carrier can be activated.</p>
<div id="rfc.figure.2"></div>
<div id="fig-client"></div>
<pre>
// connect to a server given a remote
func sayHello() {

    carrier := Initiate(local, remote)

    carrier.Send([]byte("Hello!"))
    carrier.Ready(func (msg InMessage) {
        fmt.Println(string([]byte(msg))
        return false
    })
    carrier.Close()
}
</pre>
<p class="figure">Figure 2: Example client</p>
<p id="rfc.section.3.1.1.p.3">The server in <a href="#fig-server" class="xref">Figure 3</a> creates a Listener, which accepts Carriers and passes them to a server. The server echos the content of each message it receives.</p>
<div id="rfc.figure.3"></div>
<div id="fig-server"></div>
<pre>
// run a server for a specific carrier, echo all its messages
func runMyServerOn(carrier Carrier) {
    carrier.Ready(func (msg InMessage) {
        carrier.Send(msg)
    })
}

// accept connections forever, spawn servers for them
func acceptConnections() {
    listener := Listen(local)
    listener.Accept(func(carrier Carrier) bool {
        go runMyServerOn(carrier)
        return true
    })
}
</pre>
<p class="figure">Figure 3: Example server</p>
<p id="rfc.section.3.1.1.p.4">The Responder allows the server to be significantly simplified, as shown in <a href="#fig-responder" class="xref">Figure 4</a>.</p>
<div id="rfc.figure.4"></div>
<div id="fig-responder"></div>
<pre>
func echo(msg InMessage, reply Sink) {
    reply.Send(msg)
}

Respond(local, echo)
</pre>
<p class="figure">Figure 4: Example responder</p>
<h1 id="rfc.section.3.1.2">
<a href="#rfc.section.3.1.2">3.1.2.</a> <a href="#client-server-with-happy-eyeballs-and-0-rtt-establishment" id="client-server-with-happy-eyeballs-and-0-rtt-establishment">Client-Server with Happy Eyeballs and 0-RTT establishment</a>
</h1>
<p id="rfc.section.3.1.2.p.1">The fundamental design of a client need not change at all for happy eyeballs <a href="#RFC6555" class="xref">[RFC6555]</a> (selection of multiple potential protocol stacks through connection racing); this is handled by the Post Sockets implementation automatically. If this connection racing is to use 0-RTT data (i.e., as provided by TCP Fast Open <a href="#RFC7413" class="xref">[RFC7413]</a>, the client must mark the outgoing message as idempotent.</p>
<pre>
// connect to a server given a remote and send some 0-RTT data
func sayHelloQuickly() {

    carrier := Initiate(local, remote)

    carrier.SendMsg(OutMessage{Content: []byte("Hello!"), Idempotent: true}, nil, nil, nil)
    carrier.Ready(func (msg InMessage) {
        fmt.Println(string([]byte(msg)))
        return false
    })
    carrier.Close()
}
</pre>
<h1 id="rfc.section.3.1.3">
<a href="#rfc.section.3.1.3">3.1.3.</a> <a href="#peer-to-peer-with-network-address-translation" id="peer-to-peer-with-network-address-translation">Peer to Peer with Network Address Translation</a>
</h1>
<p id="rfc.section.3.1.3.p.1">In the client-server examples shown above, the Remote given to the Initiate call refers to the name and port of the server to connect to. This need not be the case, however; a Remote may also refer to an identity and a rendezvous point for rendezvous as in ICE <a href="#RFC5245" class="xref">[RFC5245]</a>. Here, each peer does its own Initiate call simultaneously, and the result on each side is a Carrier attached to an appropriate Association.</p>
<h1 id="rfc.section.3.1.4">
<a href="#rfc.section.3.1.4">3.1.4.</a> <a href="#multicast-receiver" id="multicast-receiver">Multicast Receiver</a>
</h1>
<p id="rfc.section.3.1.4.p.1">A multicast receiver is implemented using a Sink attached to a Local encapsulating a multicast address on which to receive multicast datagrams. The following example prints messages received on the multicast address forever.</p>
<pre>
func receiveMulticast() {
    sink = NewSink(local)
    sink.Ready(func (msg InMessage) {
        fmt.Println(string([]byte(msg)))
        return true
    })
}
</pre>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#association-bootstrapping" id="association-bootstrapping">Association Bootstrapping</a>
</h1>
<p id="rfc.section.3.2.p.1">Here, we show how Association state may be initialized without a carrier.  The goal is to create a long-term Association from which Carriers may be derived and, if possible, used immediately. Per <a href="#I-D.pauly-taps-transport-security" class="xref">[I-D.pauly-taps-transport-security]</a>, a first step is to specify trust model constraints, such as pinned public keys and anchor certificates, which are needed to create Remote connections.</p>
<p id="rfc.section.3.2.p.2">We begin by creating shared security parameters that will be used later for creating a remote connection.</p>
<pre>
// create security parameters with a set of trusted certificates
func createParameters(trustedCerts []Certificate) Parameters {
    parameters := Parameters()
    parameters = parameters.SetTrustedCerts(trustedCerts)
    return parameters
}
</pre>
<p id="rfc.section.3.2.p.3">Using these statically configured parameters, we now show how to create an Association between a Local and Remote using these parameters.</p>
<pre>
// create an Association using shared parameters
func createAssociation(local Local, remote Remote, parameters Parameters) Association {
    association := AssociationWithParameters(local, remote, parameters)
    return association
}
</pre>
<p id="rfc.section.3.2.p.4">We may also create an Association with a pre-shared key configured out-of-band.</p>
<pre>
// create an Association using a pre-shared key
func createAssociationWithPSK(local Local, remote Remote, parameters Parameters, preSharedKey []byte) Association {
    association := AssociationWithParameters(local, remote, parameters)
    association = association.SetPreSharedKey(preSharedKey)
    return association
}
</pre>
<p id="rfc.section.3.2.p.5">We now show how to create a Carrier from an existing, pre-configured Association.  This Association may or may not contain shared cryptographic static between the Local and Remote, depending on how it was configured.</p>
<pre>
// open a connection to a server using an existing Association and send some data,
// which will be sent early if possible.
func sayHelloWithAssociation(association Association) {
    carrier := InitiateWithAssociation(association)

    carrier.SendMsg(OutMessage{Content: []byte("Hello!"), Idempotent: true}, nil, nil, nil)
    carrier.Ready(func (msg InMessage) {
        fmt.Println(string([]byte(msg)))
        return false
    })
    carrier.Close()
}
</pre>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#implementation-considerations" id="implementation-considerations">Implementation Considerations</a>
</h1>
<p id="rfc.section.4.p.1">Here we discuss an incomplete list of API implementation considerations that have arisen with experimentation with prototype implementations of Post.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#protocol-stack-instance-psi" id="protocol-stack-instance-psi">Protocol Stack Instance (PSI)</a>
</h1>
<p id="rfc.section.4.1.p.1">A PSI encapsulates an arbitrary stack of protocols (e.g., TCP over IPv6, SCTP over DTLS over UDP over IPv4).  PSIs provide the bridge between the interface (Carrier) plus the current state (Transients) and the implementation of a given set of transport services <a href="#I-D.ietf-taps-transports" class="xref">[I-D.ietf-taps-transports]</a>.</p>
<p id="rfc.section.4.1.p.2">A given implementation makes one or more possible protocol stacks available to its applications. Selection and configuration among multiple PSIs is based on system-level or application policies, as well as on network conditions in the provisioning domain in which a connection is made.</p>
<div id="rfc.figure.5"></div>
<div id="fig-psi"></div>
<pre>
+=========+    +=========+   +==========+      +==========+
| Carrier |    | Carrier |   | Carrier  |      | Carrier  |
+=========+    +=========+   +==========+      +==========+
     |               |              |                 |
+=========+    +=========+   +==========+      +==========+
|Transient|    |Transient|   |Transient |      |Transient |
+=========+    +=========+   +==========+      +==========+
     |                  \     /                 /        \
+=========+           +=========+      +=========+      +=========+
|   PSI   |           |   PSI   |      |   PSI   |      |   PSI   |
+===+-----++          +===+-----++     +===+-----++    ++-----+===+
    |TLS   |              |SCTP  |         |TLS   |    |   TLS|
    |TCP   |              |DTLS  |         |TCP   |    |   TCP|
    |IPv6  |              |UDP   |         |IPv6  |    |  IPv4|
    |802.3 |              |IPv6  |         |802.11|    |802.11|
    +------+              |802.3 |         +------+    +------+
                          +------+
(a) Transient  (b) Carrier multiplexing   (c) Multiple candidates
 bound to PSI   over a multi-streaming     racing during session
                transport protocol         establishment
</pre>
<p class="figure">Figure 5: Example Protocol Stack Instances</p>
<p id="rfc.section.4.1.p.3">For example, <a href="#fig-psi" class="xref">Figure 5</a>(a) shows a TLS over TCP stack, usable on most network connections. Protocols are layered to ensure that the PSI provides all the transport services required by the application.  A single PSI may be bound to multiple message carriers, as shown in <a href="#fig-psi" class="xref">Figure 5</a>(b): a multi-streaming transport protocol like QUIC or SCTP can support one carrier per stream. Where multi-streaming transport is not available, these carriers could be serviced by different PSIs on different flows. On the other hand, multiple PSIs are bound to a single transient during establishment, as shown in <a href="#fig-psi" class="xref">Figure 5</a>(c). Here, the losing PSI in a happy-eyeballs race will be terminated, and the carrier will continue using the winning PSI.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#message-framing-parsing-and-serialization" id="message-framing-parsing-and-serialization">Message Framing, Parsing, and Serialization</a>
</h1>
<p id="rfc.section.4.2.p.1">While some transports expose a byte stream abstraction, most higher level protocols impose some structure onto that byte stream. That is, the higher level protocol operates in terms of messages, protocol data units (PDUs), rather than using unstructured sequences of bytes, with each message being processed in turn.  Protocols are specified in terms of state machines acting on semantic messages, with parsing the byte stream into messages being a necessary annoyance, rather than a semantic concern.  Accordingly, Post Sockets exposes a message-based API to applications as the primary abstraction. Protocols that deal only in byte streams, such as TCP, represent their data in each direction as a single, long message. When framing protocols are placed on top of byte streams, the messages used in the API represent the framed messages within the stream.</p>
<p id="rfc.section.4.2.p.2">There are other benefits of providing a message-oriented API beyond framing PDUs that Post Sockets should provide when supported by the underlying transport. These include:</p>
<p></p>

<ul>
<li>the ability to associate deadlines with messages, for transports that care about timing;</li>
<li>the ability to provide control of reliability, choosing what messages to retransmit in the event of packet loss, and how best to make use of the data that arrived;</li>
<li>the ability to manage dependencies between messages, when some messages may not be delivered due to either packet loss or missing a deadline, in particular the ability to avoid (re-)sending data that relies on a previous transmission that was never received.</li>
</ul>
<p id="rfc.section.4.2.p.4">All require explicit message boundaries, and application-level framing of messages, to be effective. Once a message is passed to Post Sockets, it can not be cancelled or paused, but prioritization as well as lifetime and retransmission management will provide the protocol stack with all needed information to send the messages as quickly as possible without blocking transmission unnecessarily.  Post Sockets provides this by handling message, with known identity (sequence numbers, in the simple case), lifetimes, niceness, and antecedents.</p>
<p id="rfc.section.4.2.p.5">Transport protocols such as SCTP provide a message-oriented API that has similar features to those we describe. Other transports, such as TCP, do not. To support a message oriented API, while still being compatible with stream-based transport protocols, Post Sockets must provide APIs for parsing and serialising messages that understand the protocol data.  That is, we push message parsing and serialisation down into the Post Sockets stack, allowing applications to send and receive strongly typed data objects (e.g., a receive call on an HTTP Message Carrier should return an object representing the HTTP response, with pre-parsed status code, headers, and any message body, rather than returning a byte array that the application has to parse itself).  This is backwards compatible with existing protocols and APIs, since the wire format of messages does not change, but gives a Post Sockets stack additional information to allow it to make better use of modern transport services.</p>
<p id="rfc.section.4.2.p.6">The Post Sockets approach is therefore to raise the semantic level of the transport API: applications should send and receive messages in the form of meaningful, strongly typed, protocol data. Parsing and serialising such messages should be a re-usable function of the protocol stack instance not the application.  This is well-suited to implementation in modern systems languages, such as Swift, Go, Rust, or C++, but can also be implemented with some loss of type safety in C.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#message-size-limitations" id="message-size-limitations">Message Size Limitations</a>
</h1>
<p id="rfc.section.4.3.p.1">Ideally, Messages can be of infinite size. However, protocol stacks and protocol stack implementations may impose their own limits on message sizing; For example, SCTP <a href="#RFC4960" class="xref">[RFC4960]</a> and TLS <a href="#I-D.ietf-tls-tls13" class="xref">[I-D.ietf-tls-tls13]</a> impose record size limitations of 64kB and 16kB, respectively. Message sizes may also be limited by the available buffer at the receiver, since a Message must be fully assembled by the transport layer before it can be passed on to the application layer. Since not every transport protocol stack implements the signaling necessary to negotiate or expose message size limitations, these are currently configured out of band, and are probably best exposed through the policy context.</p>
<p id="rfc.section.4.3.p.2">A truly infinite message service &#8211; e.g. large file transfer where both endpoints have committed persistent storage to the message &#8211; is probably best realized as a layer above Post Sockets, and may be added as a new type of Message Carrier to a future revision of this document.</p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#back-pressure" id="back-pressure">Back-pressure</a>
</h1>
<p id="rfc.section.4.4.p.1">Regardless of how asynchronous reception is implemented, it is important for an application to be able to apply receiver back-pressure, to allow the protocol stack to perform receiver flow control. Depending on how asynchronous I/O works in the platform, this could be implemented by having a maximum number of concurrent receive callbacks, or by bounding the maximum number of outstanding, unread bytes at any given time, for example.</p>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> <a href="#associations-transients-racing-and-rendezvous" id="associations-transients-racing-and-rendezvous">Associations, Transients, Racing, and Rendezvous</a>
</h1>
<p id="rfc.section.4.5.p.1">As the network has evolved, even the simple act of establishing a connection has become increasingly complex.  Clients now regularly race multiple connections, for example over IPv4 and IPv6, to determine which protocol to use.  The choice of outgoing interface has also become more important, with differential reachability and performance from multiple interfaces. Name resolution can also give different outcomes depending on the interface the query was issued from. Finally, but often most significantly, NAT traversal, relay discovery, and path state maintenance messages are an essential part of connection establishment, especially for peer-to-peer applications.</p>
<p id="rfc.section.4.5.p.2">Post Sockets accordingly breaks communication establishment down into multiple phases:</p>
<p></p>

<ul>
<li>Gathering Locals  <br><br> The set of possible Locals is gathered.  In the simple case, this merely enumerates the local interfaces and protocols, and allocates ephemeral source ports for transients. For example, a system that has WiFi and Ethernet and supports IPv4 and IPv6 might gather four candidate locals (IPv4 on Ethernet, IPv6 on Ethernet, IPv4 on WiFi, and IPv6 on WiFi) that can form the source for a transient.  <br><br> If NAT traversal is required, the process of gathering locals becomes broadly equivalent to the ICE candidate gathering phase <a href="#RFC5245" class="xref">[RFC5245]</a>.  The endpoint determines its server reflexive locals (i.e., the translated address of a local, on the other side of a NAT) and relayed locals (e.g., via a TURN server or other relay), for each interface and network protocol. These are added to the set of candidate locals for this association.  <br><br> Gathering locals is primarily an endpoint local operation, although it might involve exchanges with a STUN server to derive server reflexive locals, or with a TURN server or other relay to derive relayed locals.  It does not involve communication with the remote.</li>
<li>Resolving the Remote  <br><br> The remote is typically a name that needs to be resolved into a set of possible addresses that can be used for communication. Resolving the remote is the process of recursively performing such name lookups, until fully resolved, to return the set of candidates for the remote of this association.  <br><br> How this is done will depend on the type of the Remote, and can also be specific to each local.  A common case is when the Remote is a DNS name, in which case it is resolved to give a set of IPv4 and IPv6 addresses representing that name.  Some types of remote might require more complex resolution. Resolving the remote for a peer-to-peer connection might involve communication with a rendezvous server, which in turn contacts the peer to gain consent to communicate and retrieve its set of candidate locals, which are returned and form the candidate remote addresses for contacting that peer.  <br><br> Resolving the remote is <em>not</em> a local operation. It will involve a directory service, and can require communication with the remote to rendezvous and exchange peer addresses.  This can expose some or all of the candidate locals to the remote.</li>
<li>Establishing Transients  <br><br> The set of candidate locals and the set of candidate remotes are paired, to derive a priority ordered set of Candidate Paths that can potentially be used to establish a connection.  <br><br> Then, communication is attempted over each candidate path, in priority order. If there are multiple candidates with the same priority, then transient establishment proceeds simultaneously and uses the transient that wins the race to be established.  Otherwise, transients establishment is sequential, paced at a rate that should not congest the network.  Depending on the chosen transport, this phase might involve racing TCP connections to a server over IPv4 and IPv6 <a href="#RFC6555" class="xref">[RFC6555]</a>, or it could involve a STUN exchange to establish peer-to-peer UDP connectivity <a href="#RFC5245" class="xref">[RFC5245]</a>, or some other means.</li>
<li>Confirming and Maintaining Transients  <br><br> Once connectivity has been established, unused resources can be released and the chosen path can be confirmed.  This is primarily required when establishing peer-to-peer connectivity, where connections supporting relayed locals that were not required can be closed, and where an associated signalling operation might be needed to inform middleboxes and proxies of the chosen path.  Keep-alive messages may also be sent, as appropriate, to ensure NAT and firewall state is maintained, so the transient remains operational.</li>
</ul>
<p id="rfc.section.4.5.p.4">By encapsulating these four phases of communication establishment into the PSI, Post Sockets aims to simplify application development.  It can provide reusable implementations of connection racing for TCP, to enable happy eyeballs, that will be automatically used by all TCP clients, for example.  With appropriate callbacks to drive the rendezvous signalling as part of resolving the remote, we believe a generic ICE implementation ought also to be possible. This procedure can even be repeated fully or partially during a connection to enable seamless hand-over and mobility within the network stack.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a>
</h1>
<p id="rfc.section.5.p.1">Many thanks to Laurent Chuat and Jason Lee at the Network Security Group at ETH Zurich for contributions to the initial design of Post Sockets. Thanks to Joe Hildebrand, Martin Thomson, and Michael Welzl for their feedback, as well as the attendees of the Post Sockets workshop in February 2017 in Zurich for the discussions, which have improved the design described herein.</p>
<p id="rfc.section.5.p.2">This work is partially supported by the European Commission under Horizon 2020 grant agreement no. 688421 Measurement and Architecture for a Middleboxed Internet (MAMI), and by the Swiss State Secretariat for Education, Research, and Innovation under contract no. 15.0268. This support does not imply endorsement.</p>
<h1 id="rfc.references">
<a href="#rfc.references">6.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">6.1.</a> Normative References</h1>
<table><tbody><tr>
<td class="reference"><b id="I-D.ietf-taps-transports">[I-D.ietf-taps-transports]</b></td>
<td class="top">
<a>Fairhurst, G.</a>, <a>Trammell, B.</a> and <a>M. Kuehlewind</a>, "<a href="https://tools.ietf.org/html/draft-ietf-taps-transports-14">Services provided by IETF transport protocols and congestion control mechanisms</a>", Internet-Draft draft-ietf-taps-transports-14, December 2016.</td>
</tr></tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">6.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-quic-transport">[I-D.ietf-quic-transport]</b></td>
<td class="top">
<a>Iyengar, J.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-05">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-ietf-quic-transport-05, August 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tls-tls13-21">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-21, July 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.iyengar-minion-protocol">[I-D.iyengar-minion-protocol]</b></td>
<td class="top">
<a>Jana, J.</a>, <a>Cheshire, S.</a> and <a>J. Graessley</a>, "<a href="https://tools.ietf.org/html/draft-iyengar-minion-protocol-02">Minion - Wire Protocol</a>", Internet-Draft draft-iyengar-minion-protocol-02, October 2013.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.kuehlewind-taps-crypto-sep">[I-D.kuehlewind-taps-crypto-sep]</b></td>
<td class="top">
<a>Kuehlewind, M.</a>, <a>Pauly, T.</a> and <a>C. Wood</a>, "<a href="https://tools.ietf.org/html/draft-kuehlewind-taps-crypto-sep-00">Separating Crypto Negotiation and Communication</a>", Internet-Draft draft-kuehlewind-taps-crypto-sep-00, July 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.pauly-taps-transport-security">[I-D.pauly-taps-transport-security]</b></td>
<td class="top">
<a>Pauly, T.</a> and <a>C. Wood</a>, "<a href="https://tools.ietf.org/html/draft-pauly-taps-transport-security-00">A Survey of Transport Security Protocols</a>", Internet-Draft draft-pauly-taps-transport-security-00, July 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.trammell-plus-abstract-mech">[I-D.trammell-plus-abstract-mech]</b></td>
<td class="top">
<a>Trammell, B.</a>, "<a href="https://tools.ietf.org/html/draft-trammell-plus-abstract-mech-00">Abstract Mechanisms for a Cooperative Path Layer under Endpoint Control</a>", Internet-Draft draft-trammell-plus-abstract-mech-00, September 2016.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.trammell-plus-statefulness">[I-D.trammell-plus-statefulness]</b></td>
<td class="top">
<a>Kuehlewind, M.</a>, <a>Trammell, B.</a> and <a>J. Hildebrand</a>, "<a href="https://tools.ietf.org/html/draft-trammell-plus-statefulness-03">Transport-Independent Path Layer State Management</a>", Internet-Draft draft-trammell-plus-statefulness-03, March 2017.</td>
</tr>
<tr>
<td class="reference"><b id="MinimaLT">[MinimaLT]</b></td>
<td class="top">
<a>Petullo, W.</a>, <a>Zhang, X.</a>, <a>Solworth, J.</a>, <a>Bernstein, D.</a> and <a>T. Lange</a>, "<a>MinimaLT, Minimal-latency Networking Through Better Security</a>", May 2013.</td>
</tr>
<tr>
<td class="reference"><b id="NEAT">[NEAT]</b></td>
<td class="top">
<a>Grinnemo, K-J.</a>, <a>Tom Jones, .</a>, <a>Gorry Fairhurst, .</a>, <a>David Ros, .</a>, <a>Anna Brunstrom, .</a> and <a>. Per Hurtig</a>, "<a>Towards a Flexible Internet Transport Layer Architecture</a>", June 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC0793">[RFC0793]</b></td>
<td class="top">
<a>Postel, J.</a>, "<a href="https://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4960">[RFC4960]</b></td>
<td class="top">
<a>Stewart, R.</a>, "<a href="https://tools.ietf.org/html/rfc4960">Stream Control Transmission Protocol</a>", RFC 4960, DOI 10.17487/RFC4960, September 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5245">[RFC5245]</b></td>
<td class="top">
<a>Rosenberg, J.</a>, "<a href="https://tools.ietf.org/html/rfc5245">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</a>", RFC 5245, DOI 10.17487/RFC5245, April 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6555">[RFC6555]</b></td>
<td class="top">
<a>Wing, D.</a> and <a>A. Yourtchenko</a>, "<a href="https://tools.ietf.org/html/rfc6555">Happy Eyeballs: Success with Dual-Stack Hosts</a>", RFC 6555, DOI 10.17487/RFC6555, April 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6824">[RFC6824]</b></td>
<td class="top">
<a>Ford, A.</a>, <a>Raiciu, C.</a>, <a>Handley, M.</a> and <a>O. Bonaventure</a>, "<a href="https://tools.ietf.org/html/rfc6824">TCP Extensions for Multipath Operation with Multiple Addresses</a>", RFC 6824, DOI 10.17487/RFC6824, January 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7258">[RFC7258]</b></td>
<td class="top">
<a>Farrell, S.</a> and <a>H. Tschofenig</a>, "<a href="https://tools.ietf.org/html/rfc7258">Pervasive Monitoring Is an Attack</a>", BCP 188, RFC 7258, DOI 10.17487/RFC7258, May 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7413">[RFC7413]</b></td>
<td class="top">
<a>Cheng, Y.</a>, <a>Chu, J.</a>, <a>Radhakrishnan, S.</a> and <a>A. Jain</a>, "<a href="https://tools.ietf.org/html/rfc7413">TCP Fast Open</a>", RFC 7413, DOI 10.17487/RFC7413, December 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7556">[RFC7556]</b></td>
<td class="top">
<a>Anipko, D.</a>, "<a href="https://tools.ietf.org/html/rfc7556">Multiple Provisioning Domain Architecture</a>", RFC 7556, DOI 10.17487/RFC7556, June 2015.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#open-issues" id="open-issues">Open Issues</a>
</h1>
<p id="rfc.section.A.p.1">This document is under active development; a list of current open issues is available at https://github.com/mami-project/draft-trammell-post-sockets/issues</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Brian Trammell</span> 
	  <span class="n hidden">
		<span class="family-name">Trammell</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ietf@trammell.ch">ietf@trammell.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Colin Perkins</span> 
	  <span class="n hidden">
		<span class="family-name">Perkins</span>
	  </span>
	</span>
	<span class="org vcardline">University of Glasgow</span>
	<span class="adr">
	  <span class="vcardline">School of Computing Science</span>

	  <span class="vcardline">
		<span class="locality">Glasgow  G12 8QQ</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United Kingdom</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:csp@csperkins.org">csp@csperkins.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Tommy Pauly</span> 
	  <span class="n hidden">
		<span class="family-name">Pauly</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">1 Infinite Loop</span>

	  <span class="vcardline">
		<span class="locality">Cupertino, California 95014</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:tpauly@apple.com">tpauly@apple.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mirja Kuehlewind</span> 
	  <span class="n hidden">
		<span class="family-name">Kuehlewind</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Gloriastrasse 35</span>

	  <span class="vcardline">
		<span class="locality">8092 Zurich</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mirja.kuehlewind@tik.ee.ethz.ch">mirja.kuehlewind@tik.ee.ethz.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Chris Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">1 Infinite Loop</span>

	  <span class="vcardline">
		<span class="locality">Cupertino, California 95014</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cawood@apple.com">cawood@apple.com</a></span>

  </address>
</div>

</body>
</html>
